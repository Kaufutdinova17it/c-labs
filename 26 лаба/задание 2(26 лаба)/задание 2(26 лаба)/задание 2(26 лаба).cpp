/*Graf7. Две корпорации хотят разделить сферы влияния, выбрав два разных города для
размещения своих штаб-квартир так, чтобы все города, в некоторой округе от штабквартиры не были доступны для конкурентов.
Схема автомобильного сообщения между городами задана в текстовом файле с именем FileName в виде матрицы смежности. Первая
строка файла содержит количество городов (n, n<=25), связанных дорогами, а следующие
n строк хранят матрицу (m), m[i][j]=0, если нет дороги из города i в город j, иначе m[i][j]=1.
Даны два города-кандидата с номерами K1 и K2 для этих двух штаб-квартир. Определить
есть ли города, в которые можно попасть из обоих штаб-квартир, если двигаться от каждой
штаб-квартиры не более чем через L промежуточных городов. Перечислите номера таких
городов в порядке возрастания. Нумерация городов начинается с 1. Если таких городов нет,
выведите число (-1).
*/
#include <string>
#include <iostream>
#include <fstream>
#include <vector> // Не забываем подключить вектор
#include <set>    // Не забываем подключить множество
#include "Header.h"

using namespace std;

int main() 
{
    setlocale(LC_ALL, "rus");

    // Открываем файл с матрицей смежности
    ifstream inputFile("FileName.txt");
    if (!inputFile.is_open()) 
    {
        cout << "Ошибка: Не удалось открыть файл FileName.txt" << endl;
        return 1;
    }

    // Чтение количества городов
    int n; 
    inputFile >> n;

    // Проверка корректности размера матрицы
    if (n <= 0 || n > 25)
    {
        cout << "Ошибка: Неверное количество городов." << endl;
        return 1;
    }

    // Чтение матрицы смежности
    vector<vector<int>> adjacencyMatrix(n, vector<int>(n));
    
    cout << "Содержимое файла:" << endl; // Заголовок для вывода содержимого файла
    for (int i = 0; i < n; ++i) 
    {
        for (int j = 0; j < n; ++j)
        {
            if (!(inputFile >> adjacencyMatrix[i][j]))
            {
                cout << "Ошибка: Неверный формат данных в матрице." << endl;
                return 1;
            }
            cout << adjacencyMatrix[i][j] << " "; // Выводим элемент матрицы
        }
        cout << endl; // Переход на новую строку после каждой строки матрицы
    }

    inputFile.close(); // Закрываем файл после чтения

    // Создание графа
    Graph graph(adjacencyMatrix);

    // Проверка на симметричность матрицы
    if (!graph.isSymmetric())
    {
        cout << "Ошибка: Матрица смежности не является симметричной." << endl;
        return 1;
    }

    int K1, K2, L;
    cout << "Введите номера городов-кандидатов (K1 и K2): ";
    cin >> K1 >> K2;
    cout << "Введите максимальное количество промежуточных городов (L): ";
    cin >> L;

    // Приводим номера городов к индексации с нуля
    K1--;
    K2--;

    // Проверка корректности ввода городов
    if ((K1 < 0 || K1 >= n) || (K2 < 0 || K2 >= n) || (L < 0))
    {
        cout << "Ошибка: Неверные номера городов или значение L." << endl;
        return 1;
    }

    // Получаем доступные города из обеих штаб-квартир
    set<int> citiesFromK1 = graph.reachableCities(K1, L);
    set<int> citiesFromK2 = graph.reachableCities(K2, L);

    // Находим общие города
    vector<int> commonCities;
    for (int city : citiesFromK1) 
    {
        if (citiesFromK2.find(city) != citiesFromK2.end() && city != K1 && city != K2) 
        {
            commonCities.push_back(city + 1); // Возвращаем к индексации с единицы
        }
    }

    // Выводим результаты
    cout << "Общие города: ";
    for (int city : commonCities)
    {
        cout << city << " ";
    }
    cout << endl;

    return 0;
}





